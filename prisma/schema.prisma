generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// =======================
// ENUMS
// =======================

enum ReminderType {
  GENERAL
  AFTERCARE
  REBOOK
  PRODUCT_FOLLOWUP
  LICENSE
}

enum AllergySeverity {
  LOW
  MODERATE
  HIGH
  CRITICAL
}

enum Role {
  CLIENT
  PRO
  ADMIN
}

enum BookingStatus {
  PENDING
  ACCEPTED
  COMPLETED
  CANCELLED
  WAITLIST
}

enum BookingSource {
  REQUESTED // client sought out THIS pro (profile/looks/referral/NFC)
  DISCOVERY // client searched a service and picked whoever (closest/soonest)
  AFTERCARE // rebooked from aftercare summary link/button
}

enum ProfessionType {
  COSMETOLOGIST
  BARBER
  ESTHETICIAN
  MANICURIST
  MASSAGE_THERAPIST
  MAKEUP_ARTIST
}

enum MessageThreadContextType {
  BOOKING
  SERVICE
  OFFERING
  PRO_PROFILE
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
  NEEDS_INFO
}

enum VerificationDocumentType {
  LICENSE
  ID_CARD
  MAKEUP_PRIMARY
  MAKEUP_SECONDARY
}

enum ReminderChannel {
  SMS
  EMAIL
}

enum MediaType {
  IMAGE
  VIDEO
}

enum MediaVisibility {
  PUBLIC
  PRIVATE
}

enum WaitlistStatus {
  ACTIVE
  NOTIFIED
  BOOKED
  CANCELLED
}

enum ClientIntentType {
  VIEW_PRO
  VIEW_SERVICE
  VIEW_OFFERING
  VIEW_MEDIA
}

enum OpeningTier {
  TIER1_WAITLIST_LAPSED
  TIER2_FAVORITE_VIEWER
  TIER3_PUBLIC
}

enum OpeningStatus {
  ACTIVE
  BOOKED
  EXPIRED
  CANCELLED
}

enum ClientNoteVisibility {
  PROFESSIONALS_ONLY
  ADMIN_ONLY
  PRIVATE_TO_AUTHOR
}

enum AdminPermissionRole {
  SUPER_ADMIN
  SUPPORT
  REVIEWER
}

enum ServiceLocationType {
  SALON
  MOBILE
}

enum AftercareRebookMode {
  NONE
  BOOKED_NEXT_APPOINTMENT // pro scheduled it (show “Next appointment”)
  RECOMMENDED_WINDOW // client picks within window
}

enum ClientNotificationType {
  BOOKING
  AFTERCARE
  LAST_MINUTE
}

enum SessionStep {
  NONE

  CONSULTATION
  CONSULTATION_PENDING_CLIENT

  BEFORE_PHOTOS
  SERVICE_IN_PROGRESS

  FINISH_REVIEW
  AFTER_PHOTOS

  DONE
}

enum MediaPhase {
  BEFORE
  AFTER
  OTHER
}

enum ConsultationApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum NfcCardType {
  CLIENT_REFERRAL
  PRO_BOOKING
  SALON_WHITE_LABEL
}

enum ProfessionalLocationType {
  SALON
  SUITE
  MOBILE_BASE
}

enum BookingServiceItemType {
  BASE
  ADD_ON
}

enum NotificationType {
  BOOKING_REQUEST
  BOOKING_UPDATE
  REVIEW
}

// =======================
// CORE MODELS
// =======================
model Notification {
  id   String           @id @default(cuid())
  type NotificationType

  professionalId String
  professional   ProfessionalProfile @relation(fields: [professionalId], references: [id], onDelete: Cascade)

  actorUserId String?
  actorUser   User?   @relation("NotificationActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: SetNull)

  reviewId String?
  review   Review? @relation(fields: [reviewId], references: [id], onDelete: SetNull)

  title String
  body  String @default("")
  href  String @default("")

  dedupeKey String?
  readAt    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([professionalId, dedupeKey])
  @@index([professionalId, createdAt])
  @@index([professionalId, readAt])
  @@index([bookingId])
  @@index([reviewId])
}

model ConsultationApproval {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  status     ConsultationApprovalStatus @default(PENDING)
  approvedAt DateTime?
  rejectedAt DateTime?

  proposedServicesJson Json
  proposedTotal        Decimal?
  notes                String?

  bookingId String  @unique
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  clientId String?
  proId    String?

  @@index([status])
}

model AdminPermission {
  id String @id @default(cuid())

  adminUserId String
  role        AdminPermissionRole @default(SUPPORT)

  // Option A scopes (all optional)
  professionalId String?
  serviceId      String?
  categoryId     String?

  createdAt DateTime @default(now())

  adminUser    User                 @relation(fields: [adminUserId], references: [id])
  professional ProfessionalProfile? @relation(fields: [professionalId], references: [id])
  service      Service?             @relation(fields: [serviceId], references: [id])
  category     ServiceCategory?     @relation(fields: [categoryId], references: [id])

  // Prevent obvious duplicates
  @@unique([adminUserId, role, professionalId, serviceId, categoryId])
  @@index([adminUserId, createdAt])
  @@index([professionalId])
  @@index([serviceId])
  @@index([categoryId])
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  role      Role
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  adminActionLogs    AdminActionLog[]           @relation("AdminUserLogs")
  adminPermissions   AdminPermission[]
  sentMessages       Message[]                  @relation("UserSentMessages")
  threadParticipants MessageThreadParticipant[] @relation("UserThreadParticipants")

  notificationActor Notification[] @relation("NotificationActor")

  // NFC attribution events
  attributionActorEvents    AttributionEvent[] @relation("AttributionActor")
  attributionCreditedEvents AttributionEvent[] @relation("AttributionCredited")

  // favorites (clients favoriting pros)
  favoritePros ProfessionalFavorite[]

  // role profiles
  clientProfile       ClientProfile?
  professionalProfile ProfessionalProfile?

  // media interactions
  mediaLikes    MediaLike[]
  mediaComments MediaComment[]

  // opposite relation for MediaAsset.uploadedByUser
  uploadedMedia MediaAsset[] @relation("UploadedMedia")
  nfcCards      NfcCard[]
  tapIntents    TapIntent[]
}

model ClientProfile {
  id                   String                      @id @default(cuid())
  userId               String                      @unique
  firstName            String                      @default("")
  lastName             String                      @default("")
  phone                String?
  phoneVerifiedAt      DateTime?
  avatarUrl            String?
  intentEvents         ClientIntentEvent[]
  openingNotifications OpeningNotification[]
  notificationSettings ClientNotificationSettings?
  messageThreads       MessageThread[]             @relation("ClientThreads")

  alertBanner String?

  user User @relation(fields: [userId], references: [id])

  bookings      Booking[]
  bookingHolds  BookingHold[] // ✅ ADD THIS (opposite relation)
  notes         ClientProfessionalNote[]
  allergies     ClientAllergy[]
  reviews       Review[]
  reminders     Reminder[]
  notifications ClientNotification[]

  waitlistEntries WaitlistEntry[]
}

model ProfessionalProfile {
  id     String @id @default(cuid())
  userId String @unique

  firstName       String    @default("")
  lastName        String    @default("")
  phone           String?
  phoneVerifiedAt DateTime?

  businessName     String?
  handle           String?
  handleNormalized String? @unique

  bio       String?
  avatarUrl String?

  // Display-only (public profile)
  location String @default("") // e.g. "San Diego, CA"

  // Optional fallback timezone used for new locations or display,
  // but booking math should prefer location.timeZone
  timeZone String? @db.VarChar(64)

  // Mobile travel settings (NOT calendar math)
  mobileRadiusKm       Int?
  mobileBasePostalCode String?

  // Relationships
  user           User                          @relation(fields: [userId], references: [id])
  locations      ProfessionalLocation[]
  offerings      ProfessionalServiceOffering[]
  bookings       Booking[]
  calendarBlocks CalendarBlock[]

  notifications Notification[]

  // Licensing / verification (unchanged)
  professionType     ProfessionType?
  licenseNumber      String?
  licenseState       String?
  licenseExpiry      DateTime?
  licenseVerified    Boolean                @default(false)
  verificationStatus VerificationStatus     @default(PENDING)
  verificationDocs   VerificationDocument[]

  // Social/engagement (unchanged)
  favorites       ProfessionalFavorite[] @relation("ProFavorites")
  intentEvents    ClientIntentEvent[]
  messageThreads  MessageThread[]        @relation("ProThreads")
  mediaAssets     MediaAsset[]
  waitlistEntries WaitlistEntry[]

  autoAcceptBookings Boolean @default(false)

  // Admin / internal
  adminPermissions AdminPermission[]
  adminActionLogs  AdminActionLog[]  @relation("ProfessionalLogs")
  productSales     ProductSale[]
  nfcCards         NfcCard[]

  lastMinuteSettings LastMinuteSettings? @relation("ProLastMinuteSettings")
  lastMinuteOpenings LastMinuteOpening[] @relation("ProOpenings")

  holds BookingHold[] @relation("ProHolds") // name optional but makes it clear

  clientNotes       ClientProfessionalNote[]
  recordedAllergies ClientAllergy[] // for recordedBy relation
  reviews           Review[]
  reminders         Reminder[]

  @@index([handleNormalized])
}

model ProfessionalLocation {
  id             String @id @default(cuid())
  professionalId String

  type       ProfessionalLocationType
  name       String?
  isPrimary  Boolean                  @default(false)
  isBookable Boolean                  @default(true)

  // Address (SALON/SUITE required; MOBILE_BASE optional)
  formattedAddress String?
  addressLine1     String?
  addressLine2     String?
  city             String?
  state            String?
  postalCode       String?
  countryCode      String?
  placeId          String?

  // Geo
  lat Float?
  lng Float?

  // ✅ Source of truth for booking timezone
  timeZone String? @db.VarChar(64)

  // ✅ Source of truth for calendar hours
  // { "mon": { "enabled": true, "start": "09:00", "end": "17:00" }, ... }
  workingHours Json

  // Location-level booking defaults
  bufferMinutes        Int @default(15)
  stepMinutes          Int @default(30)
  advanceNoticeMinutes Int @default(15)
  maxDaysAhead         Int @default(365)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  professional ProfessionalProfile @relation(fields: [professionalId], references: [id], onDelete: Cascade)

  bookings Booking[]
  holds    BookingHold[]
  blocks   CalendarBlock[]

  @@index([professionalId])
  @@index([professionalId, isPrimary])
  @@index([professionalId, isBookable])
  @@index([lat, lng])
}

model AdminActionLog {
  id          String @id @default(cuid())
  adminUserId String

  // Option A: optional targets
  professionalId String?
  serviceId      String?
  categoryId     String?

  action    String
  note      String?
  createdAt DateTime @default(now())

  // Relations (named to avoid Prisma ambiguity)
  adminUser    User                 @relation("AdminUserLogs", fields: [adminUserId], references: [id])
  professional ProfessionalProfile? @relation("ProfessionalLogs", fields: [professionalId], references: [id])
  service      Service?             @relation("ServiceLogs", fields: [serviceId], references: [id])
  category     ServiceCategory?     @relation("CategoryLogs", fields: [categoryId], references: [id])

  @@index([adminUserId, createdAt])
  @@index([professionalId, createdAt])
  @@index([serviceId, createdAt])
  @@index([categoryId, createdAt])
}

model ServiceCategory {
  id               String            @id @default(cuid())
  name             String
  slug             String            @unique
  description      String?
  parentId         String?
  adminPermissions AdminPermission[]

  parent   ServiceCategory?  @relation("CategoryChildren", fields: [parentId], references: [id])
  children ServiceCategory[] @relation("CategoryChildren")

  isActive Boolean @default(true)

  services        Service[]
  adminActionLogs AdminActionLog[] @relation("CategoryLogs")
}

model ProfessionalFavorite {
  id             String   @id @default(cuid())
  professionalId String
  userId         String
  createdAt      DateTime @default(now())

  professional ProfessionalProfile @relation("ProFavorites", fields: [professionalId], references: [id])
  user         User                @relation(fields: [userId], references: [id])

  @@unique([professionalId, userId])
  @@index([professionalId, createdAt])
}

model Service {
  id                     String  @id @default(cuid())
  name                   String  @unique
  categoryId             String
  description            String?
  defaultDurationMinutes Int
  minPrice               Decimal @db.Decimal(10, 2)
  defaultImageUrl        String?
  allowMobile            Boolean @default(false)
  isActive               Boolean @default(true)
  // ✅ NEW
  isAddOnEligible        Boolean @default(false)
  addOnGroup             String? // optional: "Finish", "Treatment", etc.

  intentEvents       ClientIntentEvent[]
  lastMinuteOpenings LastMinuteOpening[] @relation("ServiceOpenings")
  adminPermissions   AdminPermission[]

  category            ServiceCategory               @relation(fields: [categoryId], references: [id])
  offerings           ProfessionalServiceOffering[]
  bookings            Booking[]
  lastMinuteRules     LastMinuteServiceRule[]       @relation("ServiceLastMinuteRules")
  permissions         ServicePermission[]
  mediaServiceTags    MediaServiceTag[]
  waitlistEntries     WaitlistEntry[]
  adminActionLogs     AdminActionLog[]              @relation("ServiceLogs")
  messageThreads      MessageThread[]               @relation("ServiceThreads")
  quotes              Quote[]                       @relation("ServiceQuotes")
  bookingServiceItems BookingServiceItem[]

  offeringAddOnLinks OfferingAddOn[] @relation("AddOnService")
}

model OfferingAddOn {
  id String @id @default(cuid())

  offeringId     String
  addOnServiceId String

  isActive      Boolean @default(true)
  sortOrder     Int     @default(0)
  isRecommended Boolean @default(false)

  priceOverride           Decimal? @db.Decimal(10, 2)
  durationOverrideMinutes Int?

  locationType ServiceLocationType?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  offering ProfessionalServiceOffering @relation(fields: [offeringId], references: [id], onDelete: Cascade)

  // ✅ add relation name to match Service.offeringAddOnLinks
  addOnService Service @relation("AddOnService", fields: [addOnServiceId], references: [id], onDelete: Restrict)

  @@unique([offeringId, addOnServiceId])
  @@index([offeringId, isActive, sortOrder])
  @@index([addOnServiceId])
}

model ServicePermission {
  id             String         @id @default(cuid())
  serviceId      String
  professionType ProfessionType
  stateCode      String?

  service Service @relation(fields: [serviceId], references: [id])

  @@index([professionType, stateCode])
}

model ProfessionalServiceOffering {
  id             String @id @default(cuid())
  professionalId String
  serviceId      String

  title       String?
  description String?

  // Prices/durations per booking mode
  salonPriceStartingAt  Decimal? @db.Decimal(10, 2)
  salonDurationMinutes  Int?
  mobilePriceStartingAt Decimal? @db.Decimal(10, 2)
  mobileDurationMinutes Int?

  // Mode flags per service
  offersInSalon Boolean @default(true)
  offersMobile  Boolean @default(false)

  customImageUrl String?

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  professional ProfessionalProfile @relation(fields: [professionalId], references: [id])
  service      Service             @relation(fields: [serviceId], references: [id])

  bookings Booking[]

  // (keep your other relations if you use them)
  messageThreads      MessageThread[]      @relation("OfferingThreads")
  quotes              Quote[]              @relation("OfferingQuotes")
  intentEvents        ClientIntentEvent[]
  lastMinuteOpenings  LastMinuteOpening[]  @relation("OfferingOpenings")
  bookingServiceItems BookingServiceItem[]
  holds               BookingHold[]

  addOns OfferingAddOn[]

  @@unique([professionalId, serviceId])
}

model LastMinuteSettings {
  id             String @id @default(cuid())
  professionalId String @unique

  enabled          Boolean @default(false)
  discountsEnabled Boolean @default(false) // ✅ NEW

  windowSameDayPct Int @default(20)
  window24hPct     Int @default(10)

  minPrice Decimal? @db.Decimal(10, 2)

  disableMon Boolean @default(false)
  disableTue Boolean @default(false)
  disableWed Boolean @default(false)
  disableThu Boolean @default(false)
  disableFri Boolean @default(false)
  disableSat Boolean @default(false)
  disableSun Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  professional ProfessionalProfile     @relation("ProLastMinuteSettings", fields: [professionalId], references: [id])
  serviceRules LastMinuteServiceRule[]
  blocks       LastMinuteBlock[]
}

model LastMinuteServiceRule {
  id         String  @id @default(cuid())
  settingsId String
  serviceId  String
  enabled    Boolean @default(true)

  minPrice Decimal? @db.Decimal(10, 2)

  settings LastMinuteSettings @relation(fields: [settingsId], references: [id])
  service  Service            @relation("ServiceLastMinuteRules", fields: [serviceId], references: [id])

  @@unique([settingsId, serviceId])
}

model LastMinuteBlock {
  id         String @id @default(cuid())
  settingsId String

  // block specific times from being offered last-minute
  startAt DateTime
  endAt   DateTime
  reason  String?

  settings LastMinuteSettings @relation(fields: [settingsId], references: [id])

  @@index([settingsId, startAt])
}

model LastMinuteOpening {
  id             String  @id @default(cuid())
  professionalId String
  serviceId      String?
  offeringId     String?

  startAt DateTime
  endAt   DateTime?

  status OpeningStatus @default(ACTIVE)

  discountPct Int?
  note        String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  professional ProfessionalProfile          @relation("ProOpenings", fields: [professionalId], references: [id])
  service      Service?                     @relation("ServiceOpenings", fields: [serviceId], references: [id])
  offering     ProfessionalServiceOffering? @relation("OfferingOpenings", fields: [offeringId], references: [id])

  notifications OpeningNotification[]

  @@index([professionalId, startAt])
  @@index([serviceId, startAt])
  @@index([status, startAt])
}

model OpeningNotification {
  id        String @id @default(cuid())
  openingId String
  clientId  String

  tier        OpeningTier
  sentAt      DateTime    @default(now())
  deliveredAt DateTime?
  openedAt    DateTime?
  clickedAt   DateTime?
  bookedAt    DateTime?

  // prevents spam + duplicates if you re-run jobs
  dedupeKey String? @unique

  opening LastMinuteOpening @relation(fields: [openingId], references: [id])
  client  ClientProfile     @relation(fields: [clientId], references: [id])

  @@unique([openingId, clientId, tier])
  @@index([clientId, sentAt])
  @@index([openingId, sentAt])
}

model ClientIntentEvent {
  id       String           @id @default(cuid())
  clientId String
  type     ClientIntentType

  professionalId String?
  serviceId      String?
  offeringId     String?
  mediaId        String?

  source    BookingSource? // DISCOVERY/REQUESTED/AFTERCARE if relevant
  createdAt DateTime       @default(now())

  // optional: helps dedupe / rate-limit spam tracking
  sessionId String?

  client       ClientProfile                @relation(fields: [clientId], references: [id])
  professional ProfessionalProfile?         @relation(fields: [professionalId], references: [id])
  service      Service?                     @relation(fields: [serviceId], references: [id])
  offering     ProfessionalServiceOffering? @relation(fields: [offeringId], references: [id])
  media        MediaAsset?                  @relation(fields: [mediaId], references: [id])

  @@index([clientId, createdAt])
  @@index([professionalId, createdAt])
  @@index([serviceId, createdAt])
  @@index([offeringId, createdAt])
  @@index([mediaId, createdAt])
}

model ClientNotificationSettings {
  id       String @id @default(cuid())
  clientId String @unique

  lastMinuteEnabled Boolean @default(true)

  // optional granularity
  maxLastMinutePerDay Int @default(2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  aftercareEnabled   Boolean @default(true)
  maxAftercarePerDay Int     @default(5)

  client ClientProfile @relation(fields: [clientId], references: [id])
}

model Booking {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clientId       String
  professionalId String
  serviceId      String
  offeringId     String?

  scheduledFor DateTime
  status       BookingStatus @default(PENDING)

  // Booking mode: SALON or MOBILE
  locationType ServiceLocationType

  // ✅ REQUIRED: lock booking to a specific ProfessionalLocation
  locationId String
  location   ProfessionalLocation @relation(fields: [locationId], references: [id], onDelete: Restrict)

  // ✅ Snapshots that make bookings immutable + timezone safe
  locationTimeZone        String? @db.VarChar(64)
  locationAddressSnapshot Json?
  locationLatSnapshot     Float?
  locationLngSnapshot     Float?

  // Client-friendly display (optional)
  clientTimeZoneAtBooking String? @db.VarChar(64)

  // Pricing + duration (new truth)
  subtotalSnapshot Decimal  @db.Decimal(10, 2)
  totalAmount      Decimal? @db.Decimal(10, 2)
  depositAmount    Decimal? @db.Decimal(10, 2)
  tipAmount        Decimal? @db.Decimal(10, 2)
  taxAmount        Decimal? @db.Decimal(10, 2)
  discountAmount   Decimal? @db.Decimal(10, 2)

  totalDurationMinutes Int
  bufferMinutes        Int @default(0)

  // Source tracking (keep)
  source            BookingSource @default(DISCOVERY)
  rebookOfBookingId String?

  internalNotes String?
  clientNotes   String?

  client       ClientProfile                @relation(fields: [clientId], references: [id])
  professional ProfessionalProfile          @relation(fields: [professionalId], references: [id])
  service      Service                      @relation(fields: [serviceId], references: [id])
  offering     ProfessionalServiceOffering? @relation(fields: [offeringId], references: [id])

  rebookOf Booking?  @relation("RebookChain", fields: [rebookOfBookingId], references: [id])
  rebooks  Booking[] @relation("RebookChain")

  // Keep the rest if you use them
  consultation            BookingConsultation?
  consultationNotes       String?
  consultationPrice       Decimal?              @db.Decimal(10, 2)
  consultationConfirmedAt DateTime?
  consultationApproval    ConsultationApproval?

  aftercareSummary    AftercareSummary?
  clientNotifications ClientNotification[]
  reviews             Review[]
  reminders           Reminder[]

  notifications Notification[]

  sessionStep           SessionStep      @default(NONE)
  reminderMinutesBefore Int?             @default(1440)
  reminderSentAt        DateTime?
  reminderChannel       ReminderChannel?

  startedAt  DateTime?
  finishedAt DateTime?

  mediaAssets             MediaAsset[]
  messageThreads          MessageThread[]          @relation("BookingThreads")
  productSales            ProductSale[]
  serviceItems            BookingServiceItem[]
  clientProfessionalNotes ClientProfessionalNote[]

  @@index([professionalId, scheduledFor])
  @@index([clientId, scheduledFor])
  @@index([locationId, scheduledFor])
  @@index([professionalId, source])
}

model BookingHold {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  offeringId     String
  professionalId String
  clientId       String?

  scheduledFor DateTime
  expiresAt    DateTime

  locationType ServiceLocationType

  // ✅ REQUIRED: hold must be tied to a specific location
  locationId String
  location   ProfessionalLocation @relation(fields: [locationId], references: [id], onDelete: Restrict)

  // snapshot timezone (prevents drift)
  locationTimeZone        String? @db.VarChar(64)
  locationAddressSnapshot Json?
  locationLatSnapshot     Float?
  locationLngSnapshot     Float?

  client       ClientProfile?              @relation(fields: [clientId], references: [id])
  offering     ProfessionalServiceOffering @relation(fields: [offeringId], references: [id])
  professional ProfessionalProfile         @relation("ProHolds", fields: [professionalId], references: [id])

  // Unique per location calendar, not global across pro
  @@unique([locationId, scheduledFor])
  @@index([professionalId, expiresAt])
  @@index([offeringId, scheduledFor])
  @@index([clientId, expiresAt])
}

model AftercareSummary {
  id           String    @id @default(cuid())
  bookingId    String    @unique
  notes        String?
  rebookedFor  DateTime?
  serviceNotes String?

  // ✅ NEW: timeframe-based recommendation (client self-rebooks)
  rebookWindowStart DateTime?
  rebookWindowEnd   DateTime?

  // ✅ NEW: tells UI what to show (simple and explicit)
  rebookMode AftercareRebookMode @default(NONE)

  publicToken String @unique @default(cuid())

  booking             Booking                 @relation(fields: [bookingId], references: [id])
  recommendations     ProductRecommendation[]
  clientNotifications ClientNotification[]
}

model Product {
  id             String   @id @default(cuid())
  name           String
  brand          String?
  description    String?
  retailPrice    Decimal? @db.Decimal(10, 2)
  wholesalePrice Decimal? @db.Decimal(10, 2)
  isActive       Boolean  @default(true)

  recommendations ProductRecommendation[]
  productSales    ProductSale[]
}

model ProductRecommendation {
  id                 String @id @default(cuid())
  aftercareSummaryId String

  // Existing path (internal store)
  productId String?

  // ✅ External link path (Amazon storefront, pro shop, etc.)
  externalName String?
  externalUrl  String?

  note String?

  aftercareSummary AftercareSummary @relation(fields: [aftercareSummaryId], references: [id])
  product          Product?         @relation(fields: [productId], references: [id])

  @@index([aftercareSummaryId])
  @@index([productId])
}

model ProductSale {
  id             String   @id @default(cuid())
  professionalId String
  bookingId      String?
  productId      String
  quantity       Int      @default(1)
  unitPrice      Decimal  @db.Decimal(10, 2)
  createdAt      DateTime @default(now())

  professional ProfessionalProfile @relation(fields: [professionalId], references: [id])
  booking      Booking?            @relation(fields: [bookingId], references: [id])
  product      Product             @relation(fields: [productId], references: [id])

  @@index([professionalId, createdAt])
  @@index([productId, createdAt])
}

model VerificationDocument {
  id             String                   @id @default(cuid())
  professionalId String
  type           VerificationDocumentType
  label          String?
  imageUrl       String?
  url            String?
  createdAt      DateTime                 @default(now())
  reviewedAt     DateTime?
  status         VerificationStatus       @default(PENDING)
  adminNote      String?

  professional ProfessionalProfile @relation(fields: [professionalId], references: [id])
}

// ✅ Pro-to-pro shared feedback about a client.
// Use this for: “notes/reviews for the client from pros who serviced them in the past”.
model ClientProfessionalNote {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Who this is about + who wrote it
  clientId       String
  professionalId String

  // Optional: tie feedback to the appointment it came from (strongly recommended)
  // If the booking is deleted, we still want the feedback to remain, so SetNull.
  bookingId String?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: SetNull)

  // Content
  title String?
  body  String

  // Optional “review-like” rating (1–5). Keep optional so it can stay a note.
  rating Int?

  // Who can see it
  visibility ClientNoteVisibility @default(PROFESSIONALS_ONLY)

  // Relations
  client       ClientProfile       @relation(fields: [clientId], references: [id], onDelete: Cascade)
  professional ProfessionalProfile @relation(fields: [professionalId], references: [id], onDelete: Cascade)

  // Prevent duplicates for the same booking+author (optional but helpful).
  // Allows multiple notes not tied to a booking.
  @@unique([professionalId, bookingId])
  @@index([clientId, createdAt])
  @@index([professionalId, createdAt])
  @@index([bookingId])
}

model Review {
  id             String   @id @default(cuid())
  clientId       String
  professionalId String
  bookingId      String?
  rating         Int
  headline       String?
  body           String?
  createdAt      DateTime @default(now())

  client       ClientProfile       @relation(fields: [clientId], references: [id])
  professional ProfessionalProfile @relation(fields: [professionalId], references: [id])
  booking      Booking?            @relation(fields: [bookingId], references: [id])

  mediaAssets MediaAsset[]

  notifications Notification[]

  @@index([professionalId, createdAt])
  @@index([clientId, createdAt])
}

model ClientAllergy {
  id                       String          @id @default(cuid())
  clientId                 String
  label                    String
  description              String?
  severity                 AllergySeverity @default(MODERATE)
  recordedByProfessionalId String?
  createdAt                DateTime        @default(now())

  client     ClientProfile        @relation(fields: [clientId], references: [id])
  recordedBy ProfessionalProfile? @relation(fields: [recordedByProfessionalId], references: [id])

  @@index([clientId])
}

model Reminder {
  id             String       @id @default(cuid())
  professionalId String
  clientId       String?
  bookingId      String?
  type           ReminderType @default(GENERAL)
  title          String
  body           String?
  dueAt          DateTime
  createdAt      DateTime     @default(now())
  completedAt    DateTime?

  dedupeKey String? @unique

  professional ProfessionalProfile @relation(fields: [professionalId], references: [id])
  client       ClientProfile?      @relation(fields: [clientId], references: [id])
  booking      Booking?            @relation(fields: [bookingId], references: [id])

  @@index([professionalId, dueAt])
  @@index([clientId, dueAt])
}

// =======================
// MEDIA MODELS
// =======================

model MediaAsset {
  id               String              @id @default(cuid())
  professionalId   String
  bookingId        String?
  reviewId         String?
  uploadedByUserId String?
  uploadedByRole   Role?
  url              String
  thumbUrl         String?
  mediaType        MediaType
  caption          String?
  createdAt        DateTime            @default(now())
  intentEvents     ClientIntentEvent[]

  visibility            MediaVisibility @default(PUBLIC)
  isFeaturedInPortfolio Boolean         @default(false)
  isEligibleForLooks    Boolean         @default(false)
  reviewLocked          Boolean         @default(false)

  professional   ProfessionalProfile @relation(fields: [professionalId], references: [id])
  booking        Booking?            @relation(fields: [bookingId], references: [id])
  review         Review?             @relation(fields: [reviewId], references: [id])
  phase          MediaPhase          @default(OTHER)
  uploadedByUser User?               @relation("UploadedMedia", fields: [uploadedByUserId], references: [id])

  services MediaServiceTag[]
  likes    MediaLike[]
  comments MediaComment[]

  waitlistEntries WaitlistEntry[]

  storageBucket String // 'media-public' | 'media-private'
  storagePath   String
  thumbBucket   String?
  thumbPath     String?
}

model MediaServiceTag {
  id        String @id @default(cuid())
  mediaId   String
  serviceId String

  media   MediaAsset @relation(fields: [mediaId], references: [id])
  service Service    @relation(fields: [serviceId], references: [id])

  @@unique([mediaId, serviceId])
}

model MediaLike {
  id        String   @id @default(cuid())
  mediaId   String
  userId    String
  createdAt DateTime @default(now())

  media MediaAsset @relation(fields: [mediaId], references: [id])
  user  User       @relation(fields: [userId], references: [id])

  @@unique([mediaId, userId])
}

model MediaComment {
  id        String   @id @default(cuid())
  mediaId   String
  userId    String
  body      String
  createdAt DateTime @default(now())

  media MediaAsset @relation(fields: [mediaId], references: [id])
  user  User       @relation(fields: [userId], references: [id])
}

// =======================
// WAITLIST
// =======================

model WaitlistEntry {
  id             String  @id @default(cuid())
  clientId       String
  professionalId String
  serviceId      String
  mediaId        String?
  notes          String?

  preferredStart      DateTime
  preferredEnd        DateTime
  preferredTimeBucket String?

  status    WaitlistStatus @default(ACTIVE)
  createdAt DateTime       @default(now())

  client       ClientProfile       @relation(fields: [clientId], references: [id])
  professional ProfessionalProfile @relation(fields: [professionalId], references: [id])
  service      Service             @relation(fields: [serviceId], references: [id])
  media        MediaAsset?         @relation(fields: [mediaId], references: [id])
}

model MessageThread {
  id             String @id @default(cuid())
  clientId       String
  professionalId String

  // ✅ context-scoped
  contextType MessageThreadContextType
  contextId   String // bookingId OR serviceId OR offeringId OR professionalId

  // Optional pointers for convenience (nice for joins, not required)
  bookingId  String?  @unique
  booking    Booking? @relation("BookingThreads", fields: [bookingId], references: [id], onDelete: SetNull)
  serviceId  String?
  offeringId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // quick inbox sorting / preview (optional but recommended)
  lastMessageAt      DateTime?
  lastMessagePreview String?

  client       ClientProfile       @relation("ClientThreads", fields: [clientId], references: [id])
  professional ProfessionalProfile @relation("ProThreads", fields: [professionalId], references: [id])

  service  Service?                     @relation("ServiceThreads", fields: [serviceId], references: [id])
  offering ProfessionalServiceOffering? @relation("OfferingThreads", fields: [offeringId], references: [id])

  messages Message[]
  quotes   Quote[]

  participants MessageThreadParticipant[]

  @@unique([clientId, professionalId, contextType, contextId])
  @@index([professionalId, updatedAt])
  @@index([clientId, updatedAt])
  @@index([contextType, contextId])
}

model MessageThreadParticipant {
  id         String    @id @default(cuid())
  threadId   String
  userId     String
  role       Role
  lastReadAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  thread MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user   User          @relation("UserThreadParticipants", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([threadId, userId])
  @@index([userId, updatedAt])
  @@index([threadId, updatedAt])
}

model Message {
  id           String   @id @default(cuid())
  threadId     String
  senderUserId String
  body         String?
  createdAt    DateTime @default(now())

  thread MessageThread @relation(fields: [threadId], references: [id])
  sender User          @relation("UserSentMessages", fields: [senderUserId], references: [id])

  attachments MessageAttachment[]

  @@index([threadId, createdAt])
}

model MessageAttachment {
  id        String    @id @default(cuid())
  messageId String
  url       String
  mediaType MediaType @default(IMAGE)
  createdAt DateTime  @default(now())

  message Message @relation(fields: [messageId], references: [id])
}

model Quote {
  id              String              @id @default(cuid())
  threadId        String
  serviceId       String
  offeringId      String?
  locationType    ServiceLocationType
  priceStartingAt Decimal?            @db.Decimal(10, 2)
  durationMinutes Int?
  notes           String?
  status          String              @default("SENT")
  createdAt       DateTime            @default(now())

  thread   MessageThread                @relation(fields: [threadId], references: [id])
  service  Service                      @relation("ServiceQuotes", fields: [serviceId], references: [id])
  offering ProfessionalServiceOffering? @relation("OfferingQuotes", fields: [offeringId], references: [id])
}

model BookingConsultation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bookingId String  @unique
  booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  // What the pro proposed
  proposedServicesJson Json?
  proposedPrice        Decimal?
  notes                String?

  // Client decision
  clientApprovedAt DateTime?
  clientDeclinedAt DateTime?
  clientMessage    String?
}

model ClientNotification {
  id       String @id @default(cuid())
  clientId String

  // what happened
  type  ClientNotificationType
  title String
  body  String?

  // linking / deep link support
  bookingId   String?
  aftercareId String?

  // for dedupe so you don’t spam them on edits
  dedupeKey String? @unique

  // read state
  readAt    DateTime?
  createdAt DateTime  @default(now())

  client    ClientProfile     @relation(fields: [clientId], references: [id])
  booking   Booking?          @relation(fields: [bookingId], references: [id])
  aftercare AftercareSummary? @relation(fields: [aftercareId], references: [id])

  @@index([clientId, createdAt])
  @@index([clientId, readAt])
}

model BookingServiceItem {
  id         String  @id @default(cuid())
  bookingId  String
  serviceId  String
  offeringId String? // base offering or add-on offering (optional)

  // ✅ NEW: classify item
  itemType BookingServiceItemType @default(BASE)

  // ✅ NEW: if this item was chosen as an add-on of a base item
  parentItemId String?
  parentItem   BookingServiceItem?  @relation("BookingServiceItemParent", fields: [parentItemId], references: [id], onDelete: SetNull)
  children     BookingServiceItem[] @relation("BookingServiceItemParent")

  // Snapshots at the time of booking
  priceSnapshot           Decimal @db.Decimal(10, 2)
  durationMinutesSnapshot Int

  // Optional: ordering + notes
  sortOrder Int      @default(0)
  notes     String?
  createdAt DateTime @default(now())

  booking  Booking                      @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  service  Service                      @relation(fields: [serviceId], references: [id])
  offering ProfessionalServiceOffering? @relation(fields: [offeringId], references: [id])

  @@index([bookingId])
  @@index([serviceId])
  @@index([bookingId, sortOrder])
  @@index([bookingId, itemType])
  @@index([parentItemId])
}

model CalendarBlock {
  id             String  @id @default(cuid())
  professionalId String
  locationId     String? // null = blocks all locations (rare, but useful)

  startsAt DateTime
  endsAt   DateTime
  note     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  professionalProfile ProfessionalProfile   @relation(fields: [professionalId], references: [id], onDelete: Cascade)
  location            ProfessionalLocation? @relation(fields: [locationId], references: [id], onDelete: SetNull)

  @@index([locationId])
  @@index([professionalId, startsAt])
  @@index([professionalId, endsAt])
}

model NfcCard {
  id   String      @id // this is what’s encoded in the NFC URL
  type NfcCardType

  // “ownership” (never changes once claimed)
  claimedAt       DateTime?
  claimedByUserId String?
  claimedByUser   User?     @relation(fields: [claimedByUserId], references: [id])

  // referral attribution (for future rewards)
  referralCount Int @default(0)

  // pro booking cards
  professionalId String?
  professional   ProfessionalProfile? @relation(fields: [professionalId], references: [id])

  // white-label salon cards (minimal tenant pointer)
  salonSlug String? // or salonId if you already have a Salon model

  isActive          Boolean            @default(true)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  tapIntents        TapIntent[]
  attributionEvents AttributionEvent[]

  @@index([type])
  @@index([claimedByUserId])
  @@index([professionalId])
  @@index([salonSlug])
}

model TapIntent {
  id     String  @id @default(cuid())
  cardId String
  card   NfcCard @relation(fields: [cardId], references: [id])

  // who it eventually belongs to (set after login/signup)
  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  // what the user was trying to do
  intentType  String // "SIGNUP_CLIENT" | "SIGNUP_PRO" | "BOOK_PRO" | "WL_SIGNUP" etc.
  payloadJson Json?

  // anti-abuse + cleanup
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([cardId])
  @@index([userId])
  @@index([expiresAt])
}

model AttributionEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  eventType String

  cardId String?
  card   NfcCard? @relation(fields: [cardId], references: [id])

  actorUserId String?
  actorUser   User?   @relation("AttributionActor", fields: [actorUserId], references: [id])

  creditedUserId String?
  creditedUser   User?   @relation("AttributionCredited", fields: [creditedUserId], references: [id])

  metaJson Json?

  @@index([cardId])
  @@index([actorUserId])
  @@index([creditedUserId])
}
